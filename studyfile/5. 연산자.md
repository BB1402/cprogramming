```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//연산자(operator)
//프로그램에서 연산을 진행할 때 사용하는 기호
//ex) 10 + 5 라고 할 때 연산자는 +
//연산을 진행할 때 필요한 식이나 값을 항이라고 부르겠습니다.
//위의 식에서 +는 10,5 2개의 값이 필요하니 항이 2개라고 표현합니다.(이항)
//항이 1개 -> 단항 , 항이 2개 -> 이항 항이 3개 -> 삼항
int main()
{
	int a, b, c;
	a = 5;
	b = 3;

	c = a + b;
	printf("%d + %d = %d\n", a, b, c);

	c = a % b;
	printf("%d %% %d = %d\n", a, b, c);
	//산술 연산자
	//    +,   -,    * ,  /  , %
	//더하기,빼기,곱하기,나누기,나머지

	c *= 3;
	printf("c의 값 = %d\n", c);
	//대입 연산자
	// = 을 이용해 값을 대입할 수 있습니다.
	//ex) a = 5라고 하면 a에 5의 값을 대입합니다.

	//혼합 대입 연산자
	// = 전에 +,-,*,%를 작성하는 경우 대입하려는 값에 연산을 진행한 결과를 대입합니다.
	//ex) 위의 코드에서 추가적으로 다음과 같이 명령을 작성합니다.
	// a += 5;라고 적으면 a에 5를 더한 결과를 a에 대입합니다. 따라서 10이 됩니다.
	// 즉 a += 5는 a = a + 5와 같은 말입니다.

	a = 10;
	b = a++;
	printf("a = %d, b = %d\n", a, b);

	b = ++a;
	printf("a = %d, b = %d\n", a, b);
	//증감 연산자
	//변수의 값을 1 증가 / 감소 시킬 때 사용하는 연산자(단항)
	//++, --

	//작성 위치에 따라 판정이 다르게 처리됩니다.
	//b = a++일 경우를 후위형 증감 연산이라고 부르며, 이 경우에는 연산을 먼저 진행한 뒤, a의 값을 1 증가시킵니다.
	//따라서 대입 연산에 의해 b는 a(10)의 값을 대입하게 되고, 그 후에 a가 1 증가합니다.

	//b = ++a일 경우를 전위형 증감 연산이라고 부르며, 이 경우에는 a에 대한 1 증가를 먼저 진행하고, 연산을 처리합니다.
	//a가 1 증가해서 12가 되고, 그 후 b에 대입하게 됩니다. b = 12

	//관계연산자
	//연산자를 기준으로 왼쪽과 오른쪽 값의 크기를 비교해서 참 또는 거짓을 확인합니다.
	//참일 경우 1을 거짓일 경우 0으로 처리됩니다.

	//관계 연산자는 아래의 if문 같이 조건에 따라 코드를 작성하는 상황에 사용됩니다.

	a = 10;
	b = 7;

	//if(조건식)
	//{
	// 조건식이 만족할 때, 실행할 명령문;
	//}
	if (a > b)
	{
		printf("a는 b보다 큰 값입니다.\n");
	}
	if (a >= b)
	{
		printf("a는 b보다 크거나 같습니다.\n");
	}

	if(a == b) //a와 b의 크기가 동일한지를 확인합니다.
	{
		printf("a는 b와 같습니다.\n");
	}

	if (a != b)//a와 b가 서로 다른 경우를 확인합니다.
	{
		printf("a는 b와 다릅니다.\n");
	}
	return 0;
}

```
<hr/>

```c

#include <stdio.h>


int main()
{
	int a = 11;
	int b = 14;
	int c;

	printf("a = %d b = %d\n", a, b); // 11 14
	c = a & b;  //a AND b   --> 교집합
	printf("a & b = %d\n", c); // 10

	c = a | b; //a OR b    --> 합집합
	//a와 b의 값을 전부 1로 처리합니다. 이때 겹치는 값은 겹쳐집니다.
	printf("a | b = %d\n", c); //15
	//11 = 1011
	//14 = 1110
	//c  = 1111
	c = a ^ b; //a XOR b 
	//XOR(Exclusive OR) : 배타적 논리합, 대칭 차집합
	//a와 b를 비교했을 때 비트가 다른 지점을 1, 같으면 0으로 처리합니다.
	//이 연산 방식은 암호학의 기초로 많이 활용됩니다.
	//1011
	//1110
	//0101  ->  4 + 1 -> 5
	printf("a ^ b = %d\n",c);

	c = 6;
	printf("c= %d\n", ~c);
	//NOT 연산
	//비트를 반대로 처리하는 연산

	a = 1;
	c = a << 2;
	printf("c = %d\n", c);
	a = 3;
	c = a << 3;
	printf("c = %d\n", c);
	//shift 연산
	//a << 2 일 경우 a를 비트 2칸 이동합니다. 비트 2칸은 2의 2제곱(4)를 의미하니
	//a * 4로 해석이 가능합니다.

	a = 16;
	c = a >> 4;
	printf("c = %d\n", c);
	//shift 연산
	//a >> 4일 경우 a를 비트 4칸 이동합니다. 비트 4칸은 2의 4제곱(16)을 의미합니다.
	//a / 16과 동일한 결과

	//2진수 계산법
	//1. 계산할 값을 2의 제곱수로 분배합니다.
	//2. 이때 2의 0제곱(1)도 범위에 포함합니다.
	//3. 가장 큰 값부터 짤라냅니다.
	
	//제곱 수
	//1 2 4 8 16 32 64 128
	//11 = 8     + 2 + 1  --> 1011
	//14 = 8 + 4 + 2      --> 1110

	//11 & 14는 11과 14가 가지고 있는 비트 중에서 겹치는 부분만 1로 처리, 나머지는 다 0으로
	//1011
	//1110
	//1010  => 8 + 2 => 10



	//비트 연산(bitwise)
	//데이터를 비트 단위로 처리하는 연산자입니다.
	//컴퓨터는 데이터를 2진 코드로 관리합니다.(이진수)

	//비트 연산 사용 목적
	//1. 곱하기와 나누기 연산을 더 빠르게 진행할 수 있습니다.
	//2. 프로그램에서 이미지 처리하는 작업(ex. RGB 값 분리, 결합, 픽셀 값 조작)
	//3. 데이터를 압축하는 작업
	//4. 네트워크 관련 기술(프로토콜 단위에서 IP주소, 포트 번호 같은 데이터를 비트로 분리해
	//   네트워크와 호스트 부분에 대한 식별)
	//5. 임베디드 시스템(하드웨어 레지스터에 대한 조작)
	//등등 다양한 C언어 관련 기술에서 사용되는 핵심 기술 중 하나입니다.

	return 0;
}
